<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Elements · PotentialFlow.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PotentialFlow.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../quickstart/">Getting Started</a></li><li class="is-active"><a class="tocitem" href>Elements</a><ul class="internal"><li><a class="tocitem" href="#Built-in-Types"><span>Built-in Types</span></a></li><li><a class="tocitem" href="#Element-Properties"><span>Element Properties</span></a></li><li><a class="tocitem" href="#Methods-on-Vortex-Sheets"><span>Methods on Vortex Sheets</span></a></li><li><a class="tocitem" href="#Methods-on-Plates"><span>Methods on Plates</span></a></li><li><a class="tocitem" href="#Methods-on-Conformally-Mapped-Bodies"><span>Methods on Conformally-Mapped Bodies</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="../velocities/">Computing Velocities</a></li><li><a class="tocitem" href="../timemarching/">Time Marching</a></li><li><a class="tocitem" href="../noflowthrough/">Enforcing No-Flow-Through</a></li><li><a class="tocitem" href="../motions/">Plate Motions</a></li></ul></li><li><span class="tocitem">Internals</span><ul><li><a class="tocitem" href="../../internals/properties/">Handing Pairwise Interactions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Elements</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Elements</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/darwindarak/PotentialFlow.jl/blob/master/docs/src/manual/elements.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Elements"><a class="docs-heading-anchor" href="#Elements">Elements</a><a id="Elements-1"></a><a class="docs-heading-anchor-permalink" href="#Elements" title="Permalink"></a></h1><p>The library currently has these built-in potential flow elements:</p><ul><li><a href="#PotentialFlow.Vortex.Point"><code>Vortex.Point</code></a></li><li><a href="#PotentialFlow.Vortex.Blob"><code>Vortex.Blob</code></a></li><li><a href="#PotentialFlow.Vortex.Sheet"><code>Vortex.Sheet</code></a></li><li><a href="#PotentialFlow.Source.Point"><code>Source.Point</code></a></li><li><a href="#PotentialFlow.Source.Blob"><code>Source.Blob</code></a></li><li><a href="#PotentialFlow.Plates.Plate"><code>Plate</code></a> (at the moment, there can only be one plate in the fluid at at time)</li><li><a href="#PotentialFlow.Bodies.ConformalBody"><code>Bodies.ConformalBody</code></a></li></ul><p>Most functions in the library that act on elements can take either a single element, or a collection of elements. These collections can be represented as an array or a tuple. Arrays should be used when the elements are the same type, for example:</p><pre><code class="language-julia-repl hljs">julia&gt; points = Vortex.Point.(rand(ComplexF64, 5), rand(5))
5-element Vector{PotentialFlow.Points.Point{Float64, Float64}}:
 Vortex.Point(0.23603334566204692 + 0.34651701419196046im, 0.5557510873245723)
 Vortex.Point(0.3127069683360675 + 0.00790928339056074im, 0.43710797460962514)
 Vortex.Point(0.4886128300795012 + 0.21096820215853596im, 0.42471785049513144)
 Vortex.Point(0.951916339835734 + 0.9999046588986136im, 0.773223048457377)
 Vortex.Point(0.25166218303197185 + 0.9866663668987996im, 0.2811902322857298)

julia&gt; Elements.impulse(points)
1.3362266530178137 - 1.2821936908564113im

julia&gt; blobs = [Vortex.Blob(rand(ComplexF64), rand(), 0.1) for i in 1:5]
5-element Vector{PotentialFlow.Blobs.Blob{Float64, Float64}}:
 Vortex.Blob(0.20947237319807077 + 0.25137920979222494im, 0.02037486871266725, 0.1)
 Vortex.Blob(0.2877015122756894 + 0.859512136087661im, 0.07695088688120899, 0.1)
 Vortex.Blob(0.6403962459899388 + 0.8735441302706854im, 0.27858242002877853, 0.1)
 Vortex.Blob(0.7513126327861701 + 0.6448833539420931im, 0.07782644396003469, 0.1)
 Vortex.Blob(0.8481854810000327 + 0.0856351682044918im, 0.5532055454580578, 0.1)

julia&gt; Elements.impulse(blobs)
0.41217890550975256 - 0.7325028967929701im</code></pre><p>Knowing that every element has the same type allows the compiler to perform more aggressive optimizations. Tuples are used when we want to mix and match <em>different</em> element types. For example:</p><pre><code class="language-julia hljs">julia&gt; sys = (points, blobs);

julia&gt; Elements.impulse(sys)
1.7484055585275664 - 2.0146965876493814im</code></pre><p>This rest of this page documents the data types that represent these elements and some key functions that act on them. For more detailed examples, please refer to the <a href="https://github.com/darwindarak/PotentialFlow.jl/tree/master/examples">Jupyter notebooks</a>.</p><h2 id="Built-in-Types"><a class="docs-heading-anchor" href="#Built-in-Types">Built-in Types</a><a id="Built-in-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Built-in-Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Vortex.Point" href="#PotentialFlow.Vortex.Point"><code>PotentialFlow.Vortex.Point</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Vortex.Point(z::ComplexF64, Γ::Float64)</code></pre><p>A point vortex located at <code>z</code> with circulation <code>Γ</code>.</p><p>A new point vortex can be created from an existing one by treating the existing point vortex as a function and passing in the parameter you want to change as keyword arguments. For example,</p><pre><code class="language-julia-repl hljs">julia&gt; p = Vortex.Point(1.0, 1.0)
Vortex.Point(1.0 + 0.0im, 1.0)

julia&gt; p()
Vortex.Point(1.0 + 0.0im, 1.0)

julia&gt; p(Γ = 2.0)
Vortex.Point(1.0 + 0.0im, 2.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/d48ac14953b2c5b29062ef9da31152625b07e0ac/src/elements/Vortex.jl#L15-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Vortex.Blob" href="#PotentialFlow.Vortex.Blob"><code>PotentialFlow.Vortex.Blob</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Vortex.Blob(z::ComplexF64, Γ::Float64, δ::Float64)</code></pre><p>A regularized point vortex located at <code>z</code> with circulation <code>Γ</code> and blob radius <code>δ</code>.</p><p>A new vortex blob can be created from an existing one by treating the existing blob as a function and passing in the parameter you want to change as keyword arguments. For example,</p><pre><code class="language-julia-repl hljs">julia&gt; b = Vortex.Blob(1.0, 1.0, 0.1)
Vortex.Blob(1.0 + 0.0im, 1.0, 0.1)

julia&gt; b()
Vortex.Blob(1.0 + 0.0im, 1.0, 0.1)

julia&gt; b(Γ = 2.0, δ = 0.01)
Vortex.Blob(1.0 + 0.0im, 2.0, 0.01)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/d48ac14953b2c5b29062ef9da31152625b07e0ac/src/elements/Vortex.jl#L52-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Vortex.Sheet" href="#PotentialFlow.Vortex.Sheet"><code>PotentialFlow.Vortex.Sheet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Vortex.Sheet &lt;: Elements.Element</code></pre><p>A vortex sheet represented by vortex blob control points</p><p><strong>Fields</strong></p><ul><li><code>blobs</code>: the underlying array of vortex blobs</li><li><code>Ss</code>: the cumulated sum of circulation starting from the first control point</li><li><code>δ</code>: the blob radius of all the vortex blobs</li><li><code>zs</code>: a mapped array that accesses the position of each control point</li></ul><p><strong>Constructors:</strong></p><ul><li><code>Vortex.Sheet(blobs, Γs, δ)</code></li><li><code>Vortex.Sheet(zs, Γs, δ)</code> where <code>zs</code> is an array of positions for the control points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/d48ac14953b2c5b29062ef9da31152625b07e0ac/src/elements/Vortex.jl#L91-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Source.Point" href="#PotentialFlow.Source.Point"><code>PotentialFlow.Source.Point</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Source.Point(z::ComplexF64, S::Float64)</code></pre><p>A point source located at <code>z</code> with strength <code>S</code>.</p><p>A new point source can be created from an existing one by treating the existing source as a function and passing in the parameter you want to change as keyword arguments. For example,</p><pre><code class="language-julia-repl hljs">julia&gt; p = Source.Point(1.0, 1.0)
Source.Point(1.0 + 0.0im, 1.0)

julia&gt; p()
Source.Point(1.0 + 0.0im, 1.0)

julia&gt; p(S = 2.0)
Source.Point(1.0 + 0.0im, 2.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/d48ac14953b2c5b29062ef9da31152625b07e0ac/src/elements/Source.jl#L13-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Source.Blob" href="#PotentialFlow.Source.Blob"><code>PotentialFlow.Source.Blob</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Source.Blob(z::ComplexF64, S::Float64, δ::Float64)</code></pre><p>A regularized point source located at <code>z</code> with strength <code>S</code> and blob radius <code>δ</code>.</p><p>A new blob source can be created from an existing one by treating the existing blob as a function and passing in the parameter you want to change as keyword arguments. For example,</p><pre><code class="language-julia-repl hljs">julia&gt; b = Source.Blob(1.0, 1.0, 0.1)
Source.Blob(1.0 + 0.0im, 1.0, 0.1)

julia&gt; b()
Source.Blob(1.0 + 0.0im, 1.0, 0.1)

julia&gt; b(S = 2.0, δ = 0.01)
Source.Blob(1.0 + 0.0im, 2.0, 0.01)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/d48ac14953b2c5b29062ef9da31152625b07e0ac/src/elements/Source.jl#L52-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Plates.Plate" href="#PotentialFlow.Plates.Plate"><code>PotentialFlow.Plates.Plate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Plate &lt;: Elements.Element</code></pre><p>An infinitely thin, flat plate, represented as a bound vortex sheet</p><p><strong>Constructors</strong></p><ul><li><code>Plate(N, L, c, α)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/d48ac14953b2c5b29062ef9da31152625b07e0ac/src/elements/Plates.jl#L44-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Bodies.ConformalBody" href="#PotentialFlow.Bodies.ConformalBody"><code>PotentialFlow.Bodies.ConformalBody</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConformalBody &lt;: Elements.Element</code></pre><p>Generates a body from a conformal map. This might be a Schwarz-Christoffel map, in which case the constructor is supplied a polygon, or it might be a power- series map, in which case the constructor is given a set of complex coefficients.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; p = Bodies.Polygon([-1.0,0.2,1.0,-1.0],[-1.0,-1.0,0.5,1.0])
Polygon with 4 vertices at
             (-1.0,-1.0) (0.2,-1.0) (1.0,0.5) (-1.0,1.0)
             interior angles/π = [0.5, 0.656, 0.422, 0.422]

julia&gt; Bodies.ConformalBody(p)
Body generated by: Schwarz-Christoffel map of unit circle to exterior of polygon with 4 vertices

  centroid at 0.0 + 0.0im
  angle 0.0

julia&gt; a1 = 1; b1 = 0.1; ccoeff = ComplexF64[0.5(a1+b1),0,0.5(a1-b1)];

julia&gt; Bodies.ConformalBody(ccoeff,ComplexF64(1.0),π/4)
Body generated by: Power series map

  centroid at 1.0 + 0.0im
  angle 0.7854</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/d48ac14953b2c5b29062ef9da31152625b07e0ac/src/elements/Bodies.jl#L76-L105">source</a></section></article><h2 id="Element-Properties"><a class="docs-heading-anchor" href="#Element-Properties">Element Properties</a><a id="Element-Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Element-Properties" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Elements.position" href="#PotentialFlow.Elements.position"><code>PotentialFlow.Elements.position</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Elements.position(src::Element)</code></pre><p>Returns the complex position of a potential flow element. This is a required method for all <code>Element</code> types.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; point = Vortex.Point(1.0 + 0.0im, 1.0);

julia&gt; Elements.position(point)
1.0 + 0.0im

julia&gt; points = Vortex.Point.([1.0im, 2.0im], 1.0);

julia&gt; Elements.position.(points)
2-element Array{Complex{Float64},1}:
 0.0 + 1.0im
 0.0 + 2.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/d48ac14953b2c5b29062ef9da31152625b07e0ac/src/Elements.jl#L47-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Elements.circulation" href="#PotentialFlow.Elements.circulation"><code>PotentialFlow.Elements.circulation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Elements.circulation(src)</code></pre><p>Returns the total circulation contained in <code>src</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; points = Vortex.Point.([1.0im, 2.0im], [1.0, 2.0]);

julia&gt; blobs = Vortex.Blob.([1.0im, 2.0im], [1.0, 2.0], 0.1);

julia&gt; Elements.circulation(points[1])
1.0

julia&gt; Elements.circulation(points)
3.0

julia&gt; Elements.circulation((points, blobs))
6.0

julia&gt; Elements.circulation.(points)
2-element Array{Float64,1}:
 1.0
 2.0

julia&gt; Elements.circulation.((points, blobs))
(3.0, 3.0)

julia&gt; Elements.circulation(Source.Point(rand(), rand()))
0.0

julia&gt; Elements.circulation(Source.Blob(rand(), rand(), rand()))
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/d48ac14953b2c5b29062ef9da31152625b07e0ac/src/Elements.jl#L85-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Elements.flux" href="#PotentialFlow.Elements.flux"><code>PotentialFlow.Elements.flux</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Elements.flux(src)</code></pre><p>Returns the flux through a unit circle induced by <code>src</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; points = Source.Point.([1.0im, 2.0im], [1.0, 2.0]);

julia&gt; blobs = Source.Blob.([1.0im, 2.0im], [1.0, 2.0], 0.1);

julia&gt; Elements.flux(points[1])
1.0

julia&gt; Elements.flux((points, blobs))
6.0

julia&gt; Elements.flux.(points)
2-element Array{Float64,1}:
 1.0
 2.0

julia&gt; Elements.flux.((points, blobs))
(3.0, 3.0)

julia&gt; Elements.flux(Vortex.Point(rand(), rand()))
0.0

julia&gt; Elements.flux(Vortex.Blob(rand(), rand(), rand()))
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/d48ac14953b2c5b29062ef9da31152625b07e0ac/src/Elements.jl#L127-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Elements.impulse" href="#PotentialFlow.Elements.impulse"><code>PotentialFlow.Elements.impulse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Elements.impulse(src)</code></pre><p>Return the aerodynamic impulse of <code>src</code> about (0,0):</p><p class="math-container">\[P := \int \boldsymbol{x} \times \boldsymbol{\omega}\,\mathrm{d}A.\]</p><p>This is a required method for all vortex types.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sys = (Vortex.Point(1.0im, π), Vortex.Blob(1.0im, -π, 0.1));

julia&gt; Elements.impulse(sys[1])
3.141592653589793 + 0.0im

julia&gt; Elements.impulse(sys)
0.0 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/d48ac14953b2c5b29062ef9da31152625b07e0ac/src/Elements.jl#L166-L186">source</a></section></article><h2 id="Methods-on-Vortex-Sheets"><a class="docs-heading-anchor" href="#Methods-on-Vortex-Sheets">Methods on Vortex Sheets</a><a id="Methods-on-Vortex-Sheets-1"></a><a class="docs-heading-anchor-permalink" href="#Methods-on-Vortex-Sheets" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Sheets.append_segment!" href="#PotentialFlow.Sheets.append_segment!"><code>PotentialFlow.Sheets.append_segment!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Sheets.append_segment!(sheet::Sheet, z, Γ)</code></pre><p>Append a new segment with circulation <code>Γ</code> extending from the end of the sheet to <code>z</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sheet = Vortex.Sheet(0:0.1:1, 0.0:10, 0.2)
Vortex Sheet: L ≈ 1.0, Γ = 10.0, δ = 0.2

julia&gt; sheet.blobs[end]
Vortex.Blob(1.0 + 0.0im, 0.5, 0.2)

julia&gt; Sheets.append_segment!(sheet, 1.1, 2.0)

julia&gt; sheet
Vortex Sheet: L ≈ 1.1, Γ = 12.0, δ = 0.2

julia&gt; sheet.blobs[end]
Vortex.Blob(1.1 + 0.0im, 1.0, 0.2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/d48ac14953b2c5b29062ef9da31152625b07e0ac/src/elements/sheets/surgery.jl#L259-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Sheets.truncate!" href="#PotentialFlow.Sheets.truncate!"><code>PotentialFlow.Sheets.truncate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Sheets.truncate!(sheet, n::Int)</code></pre><p>Remove segments <code>0:n</code> from <code>sheet</code>, and return the circulation in those segments.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sheet = Vortex.Sheet(0:0.1:1, 0.0:10, 0.2)
Vortex Sheet: L ≈ 1.0, Γ = 10.0, δ = 0.2

julia&gt; Sheets.truncate!(sheet, 5)
4.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/d48ac14953b2c5b29062ef9da31152625b07e0ac/src/elements/sheets/surgery.jl#L65-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Sheets.redistribute_points!" href="#PotentialFlow.Sheets.redistribute_points!"><code>PotentialFlow.Sheets.redistribute_points!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Sheets.redistribute_points!(sheet, zs, Γs)</code></pre><p>Returns the modified sheet with replacement control points at positions <code>zs</code> and strength <code>Γs</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; sheet = Vortex.Sheet(0:0.1:1, 0.0:10, 0.2)
Vortex Sheet: L ≈ 1.0, Γ = 10.0, δ = 0.2

julia&gt; sys = (sheet,)
(Vortex Sheet: L ≈ 1.0, Γ = 10.0, δ = 0.2,)

julia&gt; Sheets.redistribute_points!(sheet, 0:0.2:2, 0.0:0.5:5)
Vortex Sheet: L ≈ 2.0, Γ = 5.0, δ = 0.2

julia&gt; sys[1]
Vortex Sheet: L ≈ 2.0, Γ = 5.0, δ = 0.2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/d48ac14953b2c5b29062ef9da31152625b07e0ac/src/elements/sheets/surgery.jl#L4-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Sheets.remesh" href="#PotentialFlow.Sheets.remesh"><code>PotentialFlow.Sheets.remesh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Sheets.remesh(sheet, Δs::Float64 , params::Tuple = ())</code></pre><p>Uniformly redistribute the control points of the sheet to have a nominal spacing of <code>Δs</code>. Material quantities that should be redistributed along with the control points can be passed in as elements of <code>params</code>.</p><p>Returns the tuple <code>(z₌, Γ₌, L [, p₌])</code> where</p><ul><li><code>z₌</code> is an array with the positions of the uniformly distributed points</li><li><code>Γ₌</code> is circulation interpolated onto <code>z₌</code></li><li><code>L</code> is total length of the sheet</li><li><code>p₌</code> is a tuple containing the material quantities from <code>params</code> interpolated onto <code>z₌</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sheet = Vortex.Sheet(0:0.1:1, 0.0:10, 0.2)
Vortex Sheet: L ≈ 1.0, Γ = 10.0, δ = 0.2

julia&gt; age = collect(10.0:-1:0);

julia&gt; Sheets.remesh(sheet, 0.2, (age, ))
(Complex{Float64}[0.0+0.0im, 0.25+0.0im, 0.5+0.0im, 0.75+0.0im, 1.0+0.0im], [0.0, 2.5, 5.0, 7.5, 10.0], 1.0, ([10.0, 7.5, 5.0, 2.5, 0.0],))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/d48ac14953b2c5b29062ef9da31152625b07e0ac/src/elements/sheets/surgery.jl#L89-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Sheets.remesh!" href="#PotentialFlow.Sheets.remesh!"><code>PotentialFlow.Sheets.remesh!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Sheets.remesh!(sheet::Sheet, Δs::Float64, params::Tuple = ())</code></pre><p>Same as <a href="#PotentialFlow.Sheets.remesh"><code>Sheets.remesh</code></a>, except <code>sheet</code> is replaced internally by a uniformly interpolated control points. Returns the tuple (sheet, L, p₌) where</p><ul><li><code>sheet</code> is the modified sheet</li><li><code>L</code> is total length of the sheet</li><li><code>p₌</code> is a tuple containing the material quantities from <code>params</code> interpolated onto the new control points of <code>sheet</code></li></ul><pre><code class="language-julia-repl hljs">julia&gt; sheet = Vortex.Sheet(0:0.1:1, 0.0:10, 0.2)
Vortex Sheet: L ≈ 1.0, Γ = 10.0, δ = 0.2

julia&gt; age = collect(10.0:-1:0);

julia&gt; Sheets.remesh!(sheet, 0.2, (age,));

julia&gt; Elements.position.(sheet.blobs)
5-element Array{Complex{Float64},1}:
  0.0 + 0.0im
 0.25 + 0.0im
  0.5 + 0.0im
 0.75 + 0.0im
  1.0 + 0.0im

julia&gt; age
5-element Array{Float64,1}:
 10.0
  7.5
  5.0
  2.5
  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/d48ac14953b2c5b29062ef9da31152625b07e0ac/src/elements/sheets/surgery.jl#L146-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Sheets.split!" href="#PotentialFlow.Sheets.split!"><code>PotentialFlow.Sheets.split!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Sheets.split!(sheet, n::Int)</code></pre><p>Remove segments <code>0:n</code> from <code>sheet</code>, and return those segments as a new sheet.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sheet = Vortex.Sheet(0:0.1:1, 0.0:10, 0.2)
Vortex Sheet: L ≈ 1.0, Γ = 10.0, δ = 0.2

julia&gt; sheet₋ = Sheets.split!(sheet, 5)
Vortex Sheet: L ≈ 0.4, Γ = 4.0, δ = 0.2

julia&gt; sheet
Vortex Sheet: L ≈ 0.6, Γ = 6.0, δ = 0.2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/d48ac14953b2c5b29062ef9da31152625b07e0ac/src/elements/sheets/surgery.jl#L34-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Sheets.filter!" href="#PotentialFlow.Sheets.filter!"><code>PotentialFlow.Sheets.filter!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Sheets.filter!(sheet, Δs, Δf[, params])</code></pre><p>Redistribute and filter the control points of a vortex sheet</p><p><strong>Arguments</strong></p><ul><li><code>sheet</code>: the vortex sheet to be modified</li><li><code>Δs</code>: the nominal spacing between the uniform points</li><li><code>Δf</code>: the minimum length scale that the filter should allow to pass through</li><li><code>params</code>: an optional tuple of vectors containing material properties</li></ul><p><strong>Returns</strong></p><p>If <code>params</code> is passed in, then its vectors will be overwritten by their interpolated values on the new control points, and the function returns the tuple (sheet, params). Otherwise, it returns (sheet, ())</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/d48ac14953b2c5b29062ef9da31152625b07e0ac/src/elements/sheets/surgery.jl#L290-L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Sheets.filter_position!" href="#PotentialFlow.Sheets.filter_position!"><code>PotentialFlow.Sheets.filter_position!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Sheets.filter_position!(s, Δf, L = arclength(z₌))</code></pre><p>Filter out any length scales in <code>s</code> that is smaller than <code>Δf</code>, storing the result back in <code>s</code>. <code>s</code> can be either a vector of complex positions, or a <code>Vortex.Sheet</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/d48ac14953b2c5b29062ef9da31152625b07e0ac/src/elements/sheets/surgery.jl#L327-L332">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Sheets.arclength" href="#PotentialFlow.Sheets.arclength"><code>PotentialFlow.Sheets.arclength</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Sheets.arclength(s)</code></pre><p>Compute the polygonal arc length of <code>s</code>, where <code>s</code> can be either an vector of complex numbers or a <code>Vortex.Sheet</code>.</p><p><strong>Example</strong></p><p>```jldoctest julia&gt; sheet = Vortex.Sheet(0:0.1:1, 0.0:10, 0.2) Vortex Sheet: L ≈ 1.0, Γ = 10.0, δ = 0.2</p><p>julia&gt; Sheets.arclength(sheet) 1.0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/d48ac14953b2c5b29062ef9da31152625b07e0ac/src/elements/sheets/surgery.jl#L197-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Sheets.arclengths" href="#PotentialFlow.Sheets.arclengths"><code>PotentialFlow.Sheets.arclengths</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Sheets.arclengths(s)</code></pre><p>Cumulative sum of the polygonal arc length of <code>s</code>, where <code>s</code> can be either an vector of complex numbers or a <code>Vortex.Sheet</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sheet = Vortex.Sheet(0:0.1:1, 0.0:10, 0.2)
Vortex Sheet: L ≈ 1.0, Γ = 10.0, δ = 0.2

julia&gt; Sheets.arclengths(sheet)
11-element Array{Float64,1}:
 0.0
 0.1
 0.2
 0.3
 0.4
 0.5
 0.6
 0.7
 0.8
 0.9
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/d48ac14953b2c5b29062ef9da31152625b07e0ac/src/elements/sheets/surgery.jl#L221-L247">source</a></section></article><h2 id="Methods-on-Plates"><a class="docs-heading-anchor" href="#Methods-on-Plates">Methods on Plates</a><a id="Methods-on-Plates-1"></a><a class="docs-heading-anchor-permalink" href="#Methods-on-Plates" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Plates.edges" href="#PotentialFlow.Plates.edges"><code>PotentialFlow.Plates.edges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">edges(plate)</code></pre><p>Return the coordinates of the leading and trailing edges</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; p = Plate(128, 1.0, 0, π/4)
Plate: N = 128, L = 1.0, c = 0.0 + 0.0im, α = 45.0ᵒ
       LESP = 0.0, TESP = 0.0

julia&gt; Plates.edges(p)
(0.3535533905932738 + 0.35355339059327373im, -0.3535533905932738 - 0.35355339059327373im)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/d48ac14953b2c5b29062ef9da31152625b07e0ac/src/elements/Plates.jl#L325-L340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Plates.enforce_no_flow_through!" href="#PotentialFlow.Plates.enforce_no_flow_through!"><code>PotentialFlow.Plates.enforce_no_flow_through!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">enforce_no_flow_through!(p::Plate, motion, elements, t)</code></pre><p>Update the plate, <code>p</code>, to enforce the no-flow-through condition given ambient vortex elements, <code>elements</code>, and while moving with kinematics specified by <code>motion</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; plate = Plate(128, 2.0, 0.0, π/3)
Plate: N = 128, L = 2.0, c = 0.0 + 0.0im, α = 60.0ᵒ
       LESP = 0.0, TESP = 0.0

julia&gt; motion = Plates.RigidBodyMotion(1.0, 0.0);

julia&gt; point = Vortex.Point(0.0 + 2im, 1.0);

julia&gt; Plates.enforce_no_flow_through!(plate, motion, point, 0.0)

julia&gt; plate
Plate: N = 128, L = 2.0, c = 0.0 + 0.0im, α = 60.0ᵒ
       LESP = 1.27, TESP = -1.93</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/d48ac14953b2c5b29062ef9da31152625b07e0ac/src/elements/plates/boundary_conditions.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Plates.vorticity_flux" href="#PotentialFlow.Plates.vorticity_flux"><code>PotentialFlow.Plates.vorticity_flux</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vorticity_flux(p::Plate, v₁, v₂,
               lesp = 0.0, tesp = 0.0,
               ∂C₁ = Vector{ComplexF64}(undef, plate.N),
               ∂C₂ = Vector{ComplexF64}(undef, plate.N)[,clamp_constraints=false])</code></pre><p>Return strengths of new vortex elements that satisfies edge suction parameters. For a given edge, if the current suction parameter is less than the criticial suction parameter, then no vorticity is released.  If it is higher, however, vorticity will be released so that the suction parameter equals the critical value. If <code>clamp_constraints=true</code>, and if one of the constraints is currently satisfied, then it fixes the constraint at that critical value while it solves for new strengths. The default is <code>false</code>, in which it does not assign any new strength to a vortex element if the associated constraint is satisfied.</p><p><strong>Arguments</strong></p><ul><li><code>p</code>: the plate</li><li><code>v₁, v₂</code>: the vortex elements (with unit circulation) that the vorticity flux is going into</li><li><code>lesp</code>, <code>tesp</code>: the critical leading and trailing edge suction parameters we want to enforce.  By default, both parameters are set to 0.0 to enforce the Kutta condition on both edges.  We can disable vortex shedding from an edge by setting the its critical suction parameter to <code>Inf</code></li></ul><p><strong>Returns</strong></p><ul><li><code>Γ₁, Γ₂</code>: the strengths that the vortex element should have in order to satisfy the edge suction parameters</li><li><code>∂C₁, ∂C₂</code>: Chebyshev coefficients of the normal velocity induced by the vortex elements Instead of running <code>enforce_bc!</code> with the new vortex elements, we can use this matrix to directly update the Chebyshev coefficients associated with the bound vortex sheet without recomputing all the velocities.</li></ul><p><strong>Example</strong></p><p>Enforcing the trailing edge Kutta condition with an point vortex at negative infinity:</p><pre><code class="language-julia-repl hljs">julia&gt; plate = Plate(128, 2.0, 0.0, π/6)
Plate: N = 128, L = 2.0, c = 0.0 + 0.0im, α = 30.0ᵒ
       LESP = 0.0, TESP = 0.0

julia&gt; motion = Plates.RigidBodyMotion(1.0, 0.0);

julia&gt; Plates.enforce_no_flow_through!(plate, motion, (), 0.0)

julia&gt; point = Vortex.Point(-Inf, 1.0);

julia&gt; _, Γ, _, _ = Plates.vorticity_flux(plate, (), point, 0.0, Inf);

julia&gt; Γ # should equal -πULsin(α) = -π
-3.1415926535897927</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/d48ac14953b2c5b29062ef9da31152625b07e0ac/src/elements/plates/boundary_conditions.jl#L63-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Plates.vorticity_flux!" href="#PotentialFlow.Plates.vorticity_flux!"><code>PotentialFlow.Plates.vorticity_flux!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vorticity_flux!(p::Plate, v₁, v₂,
                lesp = 0.0, tesp = 0.0,
                ∂C₁ = Vector{ComplexF64}(undef,plate.N),
                ∂C₂ = Vector{ComplexF64}(undef,plate.N))</code></pre><p>In-place version of <a href="#PotentialFlow.Plates.vorticity_flux"><code>vorticity_flux</code></a>, except instead of just returning the possible changes in plate Chebyshev coefficients, we modify <code>plate.C</code> with those changes so that no-flow-through is enforced in the presence of <code>v₁</code> and <code>v₂</code> with strengths that satisfy the suction parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/d48ac14953b2c5b29062ef9da31152625b07e0ac/src/elements/plates/boundary_conditions.jl#L170-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Plates.bound_circulation" href="#PotentialFlow.Plates.bound_circulation"><code>PotentialFlow.Plates.bound_circulation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bound_circulation(plate[, s])</code></pre><p>Compute the bound circulation between the trailing edge of the plate to <code>s</code>.</p><p><code>s</code> can be either a single normalized arc length coordinate (between -1 and 1), or a whole array of coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/d48ac14953b2c5b29062ef9da31152625b07e0ac/src/elements/plates/circulation.jl#L57-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Plates.bound_circulation!" href="#PotentialFlow.Plates.bound_circulation!"><code>PotentialFlow.Plates.bound_circulation!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bound_circulation!(Γs, plate[, ss])</code></pre><p>Compute the bound circulation between the trailing edge of the plate to <code>ss</code>, then store it in <code>Γs</code>.</p><p>If an array, <code>ss</code>, with normalized arc length coordinates is omitted, then the circulation will be computed at the plate&#39;s Chebyshev nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/d48ac14953b2c5b29062ef9da31152625b07e0ac/src/elements/plates/circulation.jl#L102-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Plates.rate_of_impulse" href="#PotentialFlow.Plates.rate_of_impulse"><code>PotentialFlow.Plates.rate_of_impulse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rate_of_impulse(plate, motion, elements::Source, velocities::Source)</code></pre><p>Compute the rate of change of impulse of a vortex element and its image relative to a plate.</p><p>Note that this is not just the rate of impulse of the vortex element itself, but also includes the rate of impulse of the bound vortex sheet generated in response to the vortex element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/d48ac14953b2c5b29062ef9da31152625b07e0ac/src/elements/plates/force.jl#L3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Plates.force" href="#PotentialFlow.Plates.force"><code>PotentialFlow.Plates.force</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">force(plate, motion, elements, velocities, newelements = ())</code></pre><p>Compute the force on <code>plate</code>, given its motion and the state of the ambient vorticity.</p><p><strong>Arguments</strong></p><ul><li><code>plate</code>: the plate</li><li><code>motion</code>: a structure that contains the velocity, acceleration, and angular velocity of the plate.</li><li><code>elements</code>: vortex elements representing the ambient vorticity</li><li><code>velocities</code>: the velocities of the vortex elements</li><li><code>newelements</code>: an optional argument listing vortex elements that are just added to the flow field (it can be an element that is contained in <code>elements</code>)</li><li><code>Δt</code>: this is only required if <code>newelements</code> is not empty, we assume that the new vortex elements are created over the span of <code>Δt</code></li></ul><p><strong>Returns</strong></p><ul><li><code>F</code>: the force exerted on the plate in complex coordinates</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/d48ac14953b2c5b29062ef9da31152625b07e0ac/src/elements/plates/force.jl#L88-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Plates.surface_pressure" href="#PotentialFlow.Plates.surface_pressure"><code>PotentialFlow.Plates.surface_pressure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">surface_pressure(plate, motion, te_sys, Γs₋, Δt)</code></pre><p>Compute the pressure difference across the plate along Chebyshev nodes.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The pressure difference across the bound vortex sheet is given by:</p><p class="math-container">\[    [p]_-^+
  = -\rho \left[ \frac{1}{2}(\boldsymbol{v}^+ + \boldsymbol{v}^-)
               - \boldsymbol{v}_b
         \right]
         \cdot ( \boldsymbol{\gamma} \times \boldsymbol{\hat{n}})
    +\rho \frac{\mathrm{d}\Gamma}{\mathrm{d}t}\]</p><p>where <span>$\rho$</span> is the fluid density, <span>$\boldsymbol{v}^\pm$</span> is the velocity on either side of the plate, <span>$\boldsymbol{v}_b$</span> is the local velocity of the plate, <span>$\boldsymbol{\gamma}$</span> is the bound vortex sheet strength, and <span>$\Gamma$</span> is the integrated circulation. We will compute <span>$\frac{\mathrm{d}\Gamma}{\mathrm{d}t}$</span> using finite differences.  So we will need the circulation along the plate from a previous time-step in order to compute the current pressure distribution.  We assume that value of circulation at the trailing edge of the plate is equal the the net circulation of all the vorticity that has been shed from the trailing edge.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>plate</code>: we assume that the <code>Plate</code> structure that is passed in already enforces the no-flow-through condition</li><li><code>motion</code>: the motion of the plate used to compute <span>$\boldsymbol{v}_b$</span></li><li><code>te_sys</code>: the system of vortex elements representing the vorticity shed from the trailing edge of the plate</li><li><code>Γs₋</code>: the circulation along the plate&#39;s Chebyshev nodes, this should be equivalent to calling <code>Vortex.circulation(te_sys) .+ Vortex.bound_circulation(plate)</code> from a previous time-step.</li><li><code>Δt</code>: time-step used to compute <span>$\frac{\mathrm{d}\Gamma}{\mathrm{d}t}$</span> using finite differences</li></ul><p><strong>Returns</strong></p><ul><li><code>Δp</code>: the pressure difference across the plate along Chebyshev nodes</li><li><code>Γs₊</code>: the circulation along the plate at the current time-step (this value is used in computing the current <code>Δp</code> and can be used as the <code>Γs₋</code> for computing pressure differences at the <strong>next</strong> time-step)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/d48ac14953b2c5b29062ef9da31152625b07e0ac/src/elements/Plates.jl#L267-L313">source</a></section></article><h2 id="Methods-on-Conformally-Mapped-Bodies"><a class="docs-heading-anchor" href="#Methods-on-Conformally-Mapped-Bodies">Methods on Conformally-Mapped Bodies</a><a id="Methods-on-Conformally-Mapped-Bodies-1"></a><a class="docs-heading-anchor-permalink" href="#Methods-on-Conformally-Mapped-Bodies" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Bodies.enforce_no_flow_through!" href="#PotentialFlow.Bodies.enforce_no_flow_through!"><code>PotentialFlow.Bodies.enforce_no_flow_through!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">enforce_no_flow_through!(b::ConformalBody, motion, elements, t)</code></pre><p>Update the body, <code>b</code>, to enforce the no-flow-through condition given ambient vortex elements, <code>elements</code>, and while moving with kinematics specified by <code>motion</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; p = Bodies.Polygon([-1.0,0.2,1.0,-1.0],[-1.0,-1.0,0.5,1.0])
Polygon with 4 vertices at
             (-1.0,-1.0) (0.2,-1.0) (1.0,0.5) (-1.0,1.0)
             interior angles/π = [0.5, 0.656, 0.422, 0.422]

julia&gt; b = Bodies.ConformalBody(p)
Body generated by: Schwarz-Christoffel map of unit circle to exterior of polygon with 4 vertices

  centroid at 0.0 + 0.0im
  angle 0.0

julia&gt; motion = RigidBodyMotion(1.0, 0.0);

julia&gt; point = Vortex.Point(0.0 + 2im, 1.0);

julia&gt; Bodies.enforce_no_flow_through!(b, motion, point, 0.0)

julia&gt; b.img
1-element Array{Element,1}:
 Vortex.Point(0.0 + 0.5im, -1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/d48ac14953b2c5b29062ef9da31152625b07e0ac/src/elements/bodies/boundary_conditions.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Bodies.normal" href="#PotentialFlow.Bodies.normal"><code>PotentialFlow.Bodies.normal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">normal(ζ,v,b::ConformalBody)</code></pre><p>Returns the normal component of the complex vector(s) <code>v</code> in the physical plane at a point(s) on the surface of body <code>b</code>. Each surface point is specified by its pre-image <code>ζ</code> on the unit circle. <code>v</code> and <code>ζ</code> can be arrays of points.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; p = Bodies.Polygon([-1.0,1.0,1.0,-1.0],[-1.0,-1.0,1.0,1.0]);

julia&gt; b = Bodies.ConformalBody(p);

julia&gt; Bodies.normal(exp(im*0),exp(im*π/4),b)
0.7071067811865472</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/d48ac14953b2c5b29062ef9da31152625b07e0ac/src/elements/Bodies.jl#L132-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Bodies.tangent" href="#PotentialFlow.Bodies.tangent"><code>PotentialFlow.Bodies.tangent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tangent(ζ,v,b::ConformalBody)</code></pre><p>Returns the (counter-clockwise) tangent component of the complex vector(s) <code>v</code> in the physical plane at a point(s) on the surface of body <code>b</code>. Each surface point is specified by its pre-image <code>ζ</code> on the unit circle. <code>v</code> and <code>ζ</code> can be arrays of points.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; p = Bodies.Polygon([-1.0,1.0,1.0,-1.0],[-1.0,-1.0,1.0,1.0]);

julia&gt; b = Bodies.ConformalBody(p);

julia&gt; Bodies.tangent(exp(im*0),exp(im*π/4),b)
0.7071067811865478</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/d48ac14953b2c5b29062ef9da31152625b07e0ac/src/elements/Bodies.jl#L159-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Bodies.transform_velocity!" href="#PotentialFlow.Bodies.transform_velocity!"><code>PotentialFlow.Bodies.transform_velocity!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform_velocity!(wout, win, targets, body::ConformalBody)</code></pre><p>Transforms the velocity <code>win</code> in the circle plane of a conformal mapping to a velocity <code>wout</code> that can actually be used to transport the pre-images of elements in <code>targets</code> in this circle plane. This transformation applies the Routh correction and subtracts the relative motion of the <code>body</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a1 = 1; b1 = 0.1; ccoeff = ComplexF64[0.5(a1+b1),0,0.5(a1-b1)];

julia&gt; body = Bodies.ConformalBody(ccoeff);

julia&gt; motion = RigidBodyMotion(0,0);

julia&gt; points = Vortex.Point.([-2, 2], 1.0);

julia&gt; Bodies.enforce_no_flow_through!(body, motion, points, 0);

julia&gt; sys = (body,points);

julia&gt; ẋ = (motion, allocate_velocity(points));

julia&gt; self_induce_velocity!(ẋ, sys, 0)
(Rigid Body Motion:
  ċ = 0.0 + 0.0im
  c̈ = 0.0 + 0.0im
  α̇ = 0.0
  α̈ = 0.0
  Constant (ċ = 0 + 0im, α̇ = 0), Complex{Float64}[0.0+0.129977im, 0.0-0.129977im])

julia&gt; Bodies.transform_velocity!(ẋ, ẋ, sys, body)
(Rigid Body Motion:
  ċ = 0.0 + 0.0im
  c̈ = 0.0 + 0.0im
  α̇ = 0.0
  α̈ = 0.0
  Constant (ċ = 0 + 0im, α̇ = 0), Complex{Float64}[0.0+0.785969im, 0.0-0.785969im])</code></pre><pre><code class="nohighlight hljs">transform_velocity(win, target::ComplexF64, body::ConformalBody)</code></pre><p>Returns the velocity in the physical plane from the velocity <code>win</code> in the circle plane.</p><pre><code class="language-julia-repl hljs">julia&gt; a1 = 1; b1 = 0.1; ccoeff = ComplexF64[0.5(a1+b1),0,0.5(a1-b1)];

julia&gt; body = Bodies.ConformalBody(ccoeff,0.0+0.0im,π/4);

julia&gt; motion = RigidBodyMotion(1,0);

julia&gt; points = Vortex.Point.([-2, 2], 1.0);

julia&gt; Bodies.enforce_no_flow_through!(body, motion, points, 0);

julia&gt; sys = (body,points);

julia&gt; ζ = exp(-im*π/4);

julia&gt; w̃ = induce_velocity(ζ,sys,0);

julia&gt; w = Bodies.transform_velocity(w̃,ζ,body)
0.7497272298496697 - 0.3058889412948484im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/d48ac14953b2c5b29062ef9da31152625b07e0ac/src/elements/Bodies.jl#L326-L392">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#PotentialFlow.Bodies.ConformalBody"><code>PotentialFlow.Bodies.ConformalBody</code></a></li><li><a href="#PotentialFlow.Plates.Plate"><code>PotentialFlow.Plates.Plate</code></a></li><li><a href="#PotentialFlow.Source.Blob"><code>PotentialFlow.Source.Blob</code></a></li><li><a href="#PotentialFlow.Source.Point"><code>PotentialFlow.Source.Point</code></a></li><li><a href="#PotentialFlow.Vortex.Blob"><code>PotentialFlow.Vortex.Blob</code></a></li><li><a href="#PotentialFlow.Vortex.Point"><code>PotentialFlow.Vortex.Point</code></a></li><li><a href="#PotentialFlow.Vortex.Sheet"><code>PotentialFlow.Vortex.Sheet</code></a></li><li><a href="#PotentialFlow.Bodies.enforce_no_flow_through!"><code>PotentialFlow.Bodies.enforce_no_flow_through!</code></a></li><li><a href="#PotentialFlow.Bodies.normal"><code>PotentialFlow.Bodies.normal</code></a></li><li><a href="#PotentialFlow.Bodies.tangent"><code>PotentialFlow.Bodies.tangent</code></a></li><li><a href="#PotentialFlow.Bodies.transform_velocity!"><code>PotentialFlow.Bodies.transform_velocity!</code></a></li><li><a href="#PotentialFlow.Elements.circulation"><code>PotentialFlow.Elements.circulation</code></a></li><li><a href="#PotentialFlow.Elements.flux"><code>PotentialFlow.Elements.flux</code></a></li><li><a href="#PotentialFlow.Elements.impulse"><code>PotentialFlow.Elements.impulse</code></a></li><li><a href="#PotentialFlow.Elements.position"><code>PotentialFlow.Elements.position</code></a></li><li><a href="#PotentialFlow.Plates.bound_circulation"><code>PotentialFlow.Plates.bound_circulation</code></a></li><li><a href="#PotentialFlow.Plates.bound_circulation!"><code>PotentialFlow.Plates.bound_circulation!</code></a></li><li><a href="#PotentialFlow.Plates.edges"><code>PotentialFlow.Plates.edges</code></a></li><li><a href="#PotentialFlow.Plates.enforce_no_flow_through!"><code>PotentialFlow.Plates.enforce_no_flow_through!</code></a></li><li><a href="#PotentialFlow.Plates.force"><code>PotentialFlow.Plates.force</code></a></li><li><a href="#PotentialFlow.Plates.rate_of_impulse"><code>PotentialFlow.Plates.rate_of_impulse</code></a></li><li><a href="#PotentialFlow.Plates.surface_pressure"><code>PotentialFlow.Plates.surface_pressure</code></a></li><li><a href="#PotentialFlow.Plates.vorticity_flux"><code>PotentialFlow.Plates.vorticity_flux</code></a></li><li><a href="#PotentialFlow.Plates.vorticity_flux!"><code>PotentialFlow.Plates.vorticity_flux!</code></a></li><li><a href="#PotentialFlow.Sheets.append_segment!"><code>PotentialFlow.Sheets.append_segment!</code></a></li><li><a href="#PotentialFlow.Sheets.arclength"><code>PotentialFlow.Sheets.arclength</code></a></li><li><a href="#PotentialFlow.Sheets.arclengths"><code>PotentialFlow.Sheets.arclengths</code></a></li><li><a href="#PotentialFlow.Sheets.filter!"><code>PotentialFlow.Sheets.filter!</code></a></li><li><a href="#PotentialFlow.Sheets.filter_position!"><code>PotentialFlow.Sheets.filter_position!</code></a></li><li><a href="#PotentialFlow.Sheets.redistribute_points!"><code>PotentialFlow.Sheets.redistribute_points!</code></a></li><li><a href="#PotentialFlow.Sheets.remesh"><code>PotentialFlow.Sheets.remesh</code></a></li><li><a href="#PotentialFlow.Sheets.remesh!"><code>PotentialFlow.Sheets.remesh!</code></a></li><li><a href="#PotentialFlow.Sheets.split!"><code>PotentialFlow.Sheets.split!</code></a></li><li><a href="#PotentialFlow.Sheets.truncate!"><code>PotentialFlow.Sheets.truncate!</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quickstart/">« Getting Started</a><a class="docs-footer-nextpage" href="../velocities/">Computing Velocities »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 29 August 2023 23:36">Tuesday 29 August 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
