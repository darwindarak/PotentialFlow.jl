<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Computing Velocities · PotentialFlow.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">PotentialFlow.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../quickstart/">Getting Started</a></li><li><a class="tocitem" href="../elements/">Elements</a></li><li class="is-active"><a class="tocitem" href>Computing Velocities</a><ul class="internal"><li><a class="tocitem" href="#Sources-and-Targets"><span>Sources and Targets</span></a></li><li><a class="tocitem" href="#Methods"><span>Methods</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="../timemarching/">Time Marching</a></li><li><a class="tocitem" href="../noflowthrough/">Enforcing No-Flow-Through</a></li><li><a class="tocitem" href="../motions/">Plate Motions</a></li></ul></li><li><span class="tocitem">Internals</span><ul><li><a class="tocitem" href="../../internals/properties/">Handing Pairwise Interactions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Computing Velocities</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Computing Velocities</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/darwindarak/PotentialFlow.jl/blob/master/docs/src/manual/velocities.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Computing-Velocities"><a class="docs-heading-anchor" href="#Computing-Velocities">Computing Velocities</a><a id="Computing-Velocities-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-Velocities" title="Permalink"></a></h1><h2 id="Sources-and-Targets"><a class="docs-heading-anchor" href="#Sources-and-Targets">Sources and Targets</a><a id="Sources-and-Targets-1"></a><a class="docs-heading-anchor-permalink" href="#Sources-and-Targets" title="Permalink"></a></h2><p>Velocity computations in vortex models essentially boils down to pairwise interactions between sources and targets. We may be interested in how a system of vortex elements induces velocity on at point, at multiple points, on other vortex elements, or on itself.</p><p>The three key functions for computing velocities are</p><ul><li><a href="#PotentialFlow.Motions.induce_velocity"><code>induce_velocity(target, source, t)</code></a></li><li><a href="#PotentialFlow.Motions.induce_velocity!"><code>induce_velocity!(velocity, target, source, t)</code></a></li><li><a href="#PotentialFlow.Motions.self_induce_velocity!"><code>self_induce_velocity!(velocity, source, t)</code></a></li></ul><p>The <a href="https://docs.julialang.org/en/latest/manual/style-guide.html#Append-!-to-names-of-functions-that-modify-their-arguments-1"><code>!</code> suffix</a> in the last two function signatures indicate that the <code>velocity</code> argument will be overwritten by the results of the computation. In most cases, the induced velocities will be indpendent of the time <code>t</code>, but it is included in the function signatures for flexibility.</p><p>Sources of velocity can be any one of:</p><ul><li><p>a single vortex element, e.g.</p><pre><code class="language-julia-repl">julia&gt; src = Vortex.Point(im, 1.0);

julia&gt; induce_velocity(0.0 + 0.0im, src, 0.0)
0.15915494309189535 - 0.0im</code></pre></li><li><p>an array of homogenous vortex types, e.g.</p><pre><code class="language-julia-repl">julia&gt; srcs = Vortex.Point.([im, 1.0], 1.0);

julia&gt; induce_velocity(0.0 + 0.0im, srcs, 0.0)
0.15915494309189535 - 0.15915494309189535im</code></pre></li><li><p>a tuple of different vortex types, e.g.</p><pre><code class="language-julia-repl">julia&gt; srcs₂ = Vortex.Point.([2im, 2.0], -2.0);

julia&gt; sys = (srcs, srcs₂);

julia&gt; induce_velocity(0.0 + 0.0im, sys, 0.0)
0.0 + 0.0im</code></pre></li></ul><p>In the examples above, the target was just complex number <code>0.0 + 0.0im</code>. However we can also have</p><ul><li><p>an array of complex numbers, e.g.</p><pre><code class="language-julia-repl">julia&gt; targets = ComplexF64.(1:3);

julia&gt; induce_velocity(targets, src, 0.0)
3-element Array{Complex{Float64},1}:
 0.07957747154594767 + 0.07957747154594767im
 0.03183098861837907 + 0.06366197723675814im
 0.01591549430918953 + 0.0477464829275686im</code></pre></li><li><p>an array of vortex elements, e.g.</p><pre><code class="language-julia-repl">julia&gt; targets₂ = Vortex.Point.(im*(1.0:3), 1.0);

julia&gt; induce_velocity(targets₂, src, 0.0)
3-element Array{Complex{Float64},1}:
                  0.0 + 0.0im
 -0.15915494309189535 + 0.0im
 -0.07957747154594767 + 0.0im</code></pre></li><li><p>a tuple with any of the above, e.g.</p><pre><code class="language-julia-repl">julia&gt; targets₃ = Vortex.Point.(-3.0:-1, -1.0);

julia&gt; sys = (targets, (targets₂, targets₃));

julia&gt; induce_velocity(sys, src, 0.0)
(Complex{Float64}[0.0795775+0.0795775im, 0.031831+0.063662im, 0.0159155+0.0477465im], (Complex{Float64}[0.0+0.0im, -0.159155+0.0im, -0.0795775+0.0im], Complex{Float64}[0.0159155-0.0477465im, 0.031831-0.063662im, 0.0795775-0.0795775im]))</code></pre></li></ul><p>Since the structure of these targets can get complicated, e.g. nested tuples), the library also provides a set of functions for creating and resizing the <code>velocity</code> variable for in-place computations. For example:</p><pre><code class="language-julia-repl">julia&gt; vels = allocate_velocity(sys)
(Complex{Float64}[0.0+0.0im, 0.0+0.0im, 0.0+0.0im], (Complex{Float64}[0.0+0.0im, 0.0+0.0im, 0.0+0.0im], Complex{Float64}[0.0+0.0im, 0.0+0.0im, 0.0+0.0im]))

julia&gt; induce_velocity!(vels, sys, src, 0.0)
(Complex{Float64}[0.0795775+0.0795775im, 0.031831+0.063662im, 0.0159155+0.0477465im], (Complex{Float64}[0.0+0.0im, -0.159155+0.0im, -0.0795775+0.0im], Complex{Float64}[0.0159155-0.0477465im, 0.031831-0.063662im, 0.0795775-0.0795775im]))</code></pre><p>The remaining sections of this page list the documentation for all the relevant methods for computing velocities. More detailed examples that show these methods working together can be found in the <a href="../quickstart/#getting-started">getting started guide</a> and the <a href="https://github.com/darwindarak/VortexModel.jl/tree/master/examples">Jupyter notebooks</a>.</p><h2 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Motions.allocate_velocity" href="#PotentialFlow.Motions.allocate_velocity"><code>PotentialFlow.Motions.allocate_velocity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">allocate_velocity(srcs)</code></pre><p>Allocate arrays of <code>ComplexF64</code> to match the structure of <code>srcs</code></p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; points = Vortex.Point.(rand(ComplexF64, 2), rand(2));

julia&gt; blobs  = Vortex.Blob.(rand(ComplexF64, 3), rand(3), rand(3));

julia&gt; allocate_velocity(points)
2-element Array{Complex{Float64},1}:
 0.0 + 0.0im
 0.0 + 0.0im

julia&gt; allocate_velocity((points, blobs))
(Complex{Float64}[0.0+0.0im, 0.0+0.0im], Complex{Float64}[0.0+0.0im, 0.0+0.0im, 0.0+0.0im])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/e986a09484e198f93c1f4de2a990a3eded1a64e9/src/Motions.jl#L57-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Motions.reset_velocity!" href="#PotentialFlow.Motions.reset_velocity!"><code>PotentialFlow.Motions.reset_velocity!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">reset_velocity!(vels[, srcs])</code></pre><p>Set all velocities in <code>vels</code> to zero</p><p>If <code>srcs</code> is provided, then the arrays in <code>vels</code> are resized their source counterpart, if necessary.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ẋs = (rand(ComplexF64, 1), rand(ComplexF64, 1))
(Complex{Float64}[0.236033+0.346517im], Complex{Float64}[0.312707+0.00790928im])

julia&gt; points = Vortex.Point.(rand(ComplexF64, 2), rand(2));

julia&gt; blobs  = Vortex.Blob.(rand(ComplexF64, 3), rand(3), rand(3));

julia&gt; reset_velocity!(ẋs, (points, blobs));

julia&gt; ẋs
(Complex{Float64}[0.0+0.0im, 0.0+0.0im], Complex{Float64}[0.0+0.0im, 0.0+0.0im, 0.0+0.0im])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/e986a09484e198f93c1f4de2a990a3eded1a64e9/src/Motions.jl#L188-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Motions.induce_velocity" href="#PotentialFlow.Motions.induce_velocity"><code>PotentialFlow.Motions.induce_velocity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">induce_velocity(target, element, time)</code></pre><p>Compute the velocity induced by <code>element</code> on <code>target</code></p><p><code>target</code> can be:</p><ul><li>a <code>ComplexF64</code></li><li>a subtype of <code>Vortex.PointSource</code></li><li>an array or tuple of vortex elements</li></ul><p>while the <code>element</code> can be:</p><ul><li>any subtype of <code>Vortex.Element</code></li><li>an array or tuple of vortex elements</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; z = rand(ComplexF64)
0.23603334566204692 + 0.34651701419196046im

julia&gt; point = Vortex.Point(z, rand());

julia&gt; srcs = Vortex.Point.(rand(ComplexF64, 10), rand(10));

julia&gt; induce_velocity(z, srcs[1], 0.0)
0.08722212007570912 + 0.14002850279102955im

julia&gt; induce_velocity(point, srcs[1], 0.0)
0.08722212007570912 + 0.14002850279102955im

julia&gt; induce_velocity(z, srcs, 0.0)
-0.4453372874427177 - 0.10592646656959151im

julia&gt; induce_velocity(point, srcs, 0.0)
-0.4453372874427177 - 0.10592646656959151im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/e986a09484e198f93c1f4de2a990a3eded1a64e9/src/Motions.jl#L13-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Motions.induce_velocity!" href="#PotentialFlow.Motions.induce_velocity!"><code>PotentialFlow.Motions.induce_velocity!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">induce_velocity!(vels, target, element, time)</code></pre><p>Compute the velocity induced by <code>element</code> on <code>target</code> and store the result in <code>vels</code></p><p><code>vels</code> should be the output of a call to <a href="#PotentialFlow.Motions.allocate_velocity"><code>allocate_velocity</code></a>, <code>target</code> can be an array or tuple of vortex elements, while the <code>element</code> can be:</p><ul><li>any subtype of <code>Vortex.Element</code></li><li>an array or tuple of vortex elements</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; cluster₁ = Vortex.Point.(rand(ComplexF64, 5), rand(5));

julia&gt; cluster₂ = Vortex.Point.(rand(ComplexF64, 5), rand(5));

julia&gt; targets = (cluster₁, cluster₂);

julia&gt; sources = Vortex.Blob.(rand(ComplexF64), rand(10), 0.1);

julia&gt; ẋs = allocate_velocity(targets);

julia&gt; induce_velocity!(ẋs, targets, sources, 0.0)
(Complex{Float64}[-1.28772-1.82158im, 1.9386-1.64147im, -1.56438+1.57158im, -0.626254+0.375842im, -0.806568-0.213201im], Complex{Float64}[-0.583672-2.26031im, -0.329778-1.43388im, 0.426927+1.55352im, -0.93755+0.241361im, -1.08949-0.35598im])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/e986a09484e198f93c1f4de2a990a3eded1a64e9/src/Motions.jl#L79-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Motions.self_induce_velocity!" href="#PotentialFlow.Motions.self_induce_velocity!"><code>PotentialFlow.Motions.self_induce_velocity!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">self_induce_velocity!(vels, elements, time)</code></pre><p>Compute the self induced velocity of one or more vortex elements</p><p>This involves a recursive call to <code>self_induce_velocity!</code> and pairwise calls to <a href="#PotentialFlow.Motions.mutually_induce_velocity!"><code>mutually_induce_velocity!</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; points = Vortex.Point.([-1, 1], 1.0)
2-element Array{PotentialFlow.Points.Point{Float64},1}:
 Vortex.Point(-1.0 + 0.0im, 1.0)
 Vortex.Point(1.0 + 0.0im, 1.0)

julia&gt; vels = allocate_velocity(points)
2-element Array{Complex{Float64},1}:
 0.0 + 0.0im
 0.0 + 0.0im

julia&gt; self_induce_velocity!(vels, points, 0.0) # should be ±0.25im/π
2-element Array{Complex{Float64},1}:
 0.0 - 0.07957747154594767im
 0.0 + 0.07957747154594767im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/e986a09484e198f93c1f4de2a990a3eded1a64e9/src/Motions.jl#L127-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Motions.mutually_induce_velocity!" href="#PotentialFlow.Motions.mutually_induce_velocity!"><code>PotentialFlow.Motions.mutually_induce_velocity!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mutually_induce_velocity!(vs₁, vs₂, e₁, e₂, t)</code></pre><p>Compute the mutually induced velocities between <code>e₁</code> and <code>e₂</code> at time <code>t</code> and store the results in <code>vs₁</code> and <code>vs₂</code></p><p>The default implementation simply calls <a href="#PotentialFlow.Motions.induce_velocity!"><code>induce_velocity!</code></a> twice.  This method is meant to be overwritten to take advantage of symmetries in certain pairwise vortex interations.  For example, the velocity kernel for a point vortex is antisymmetric, so in computing the mutually induced velocities of two arrays of point vortices, we can half the number of calls to the velocity kernel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/e986a09484e198f93c1f4de2a990a3eded1a64e9/src/Motions.jl#L108-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Motions.advect!" href="#PotentialFlow.Motions.advect!"><code>PotentialFlow.Motions.advect!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">advect!(srcs₊, srcs₋, vels, Δt)</code></pre><p>Moves the elements in <code>srcs₋</code> by their corresponding velocity in <code>vels</code> over the interval <code>Δt</code> and store the results in <code>src₊</code>.</p><p><code>srcs₋</code> and <code>srcs₊</code> can be either a array of vortex elements or a tuple.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; points₋ = [Vortex.Point(x + 0im, 1.0) for x in 1:5];

julia&gt; points₊ = Vector{Vortex.Point}(undef, 5);

julia&gt; vels = [ y*im for y in 1.0:5 ];

julia&gt; advect!(points₊, points₋, vels, 1e-2);

julia&gt; points₊
5-element Array{PotentialFlow.Points.Point{Float64},1}:
 Vortex.Point(1.0 + 0.01im, 1.0)
 Vortex.Point(2.0 + 0.02im, 1.0)
 Vortex.Point(3.0 + 0.03im, 1.0)
 Vortex.Point(4.0 + 0.04im, 1.0)
 Vortex.Point(5.0 + 0.05im, 1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/e986a09484e198f93c1f4de2a990a3eded1a64e9/src/Motions.jl#L266-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PotentialFlow.Motions.advect" href="#PotentialFlow.Motions.advect"><code>PotentialFlow.Motions.advect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">advect(src::Element, velocity::ComplexF64, Δt)</code></pre><p>Return a new element that represents <code>src</code> advected by <code>velocity</code> over <code>Δt</code>.</p><p>If this method is implemented by any type <code>T</code> where <code>kind(T)</code> is a <code>Singleton</code>, then an array of type <code>AbstractArray{T}</code> can be passed in the first two arguments of <a href="#PotentialFlow.Motions.advect!"><code>advect!</code></a>. Note that this method is usually only defined for singleton elements</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; point = Vortex.Point(1.0 + 0.0, 1.0);

julia&gt; advect(point, 1.0im, 1e-2)
Vortex.Point(1.0 + 0.01im, 1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/darwindarak/PotentialFlow.jl/blob/e986a09484e198f93c1f4de2a990a3eded1a64e9/src/Motions.jl#L244-L263">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#PotentialFlow.Motions.advect"><code>PotentialFlow.Motions.advect</code></a></li><li><a href="#PotentialFlow.Motions.advect!"><code>PotentialFlow.Motions.advect!</code></a></li><li><a href="#PotentialFlow.Motions.allocate_velocity"><code>PotentialFlow.Motions.allocate_velocity</code></a></li><li><a href="#PotentialFlow.Motions.induce_velocity"><code>PotentialFlow.Motions.induce_velocity</code></a></li><li><a href="#PotentialFlow.Motions.induce_velocity!"><code>PotentialFlow.Motions.induce_velocity!</code></a></li><li><a href="#PotentialFlow.Motions.mutually_induce_velocity!"><code>PotentialFlow.Motions.mutually_induce_velocity!</code></a></li><li><a href="#PotentialFlow.Motions.reset_velocity!"><code>PotentialFlow.Motions.reset_velocity!</code></a></li><li><a href="#PotentialFlow.Motions.self_induce_velocity!"><code>PotentialFlow.Motions.self_induce_velocity!</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../elements/">« Elements</a><a class="docs-footer-nextpage" href="../timemarching/">Time Marching »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 17 May 2021 23:22">Monday 17 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
